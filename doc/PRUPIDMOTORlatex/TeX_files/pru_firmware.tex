%    Documentation for PRU ADC Project
%    Copyright (C) 2016  Gregory Raven
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.

\chapter{PRU Firmware and User-space Program}

The ``PRU Firmware'' are two binary files which are placed in the directory /lib/firmware.
These files must have specific names as follows:

\begin{itemize}
	\item am335x-pru0-fw
	\item am335x-pru1-fw
\end{itemize}

The Makefile includes cp commands to copy the firmwares to the /lib/firmware directory.

\section{The PID Firmware in PRU0:  Digital Feedback Loop (PRU\_PID\_0.c)}

This C program defines a struct ``shared\_mem'' which contains another struct ``pid\_data''. This same struct is also defined in the PRU1 code.  It is this common data structure which allows the two PRUs to communicate.

The following code fragment shows how the PRU shared memory is arranged:

\begin{verbatim}
#pragma DATA_SECTION(share_buff, ".share_buff")
volatile far struct shared_mem share_buff;
\end{verbatim}

In addition to the code in the C files, the ``DATA\_SECTION'' must be defined in the linker command file AM335x\_PRU.cmd:

\begin{verbatim}
	  PAGE 2:
	PRU_SHAREDMEM	: org = 0x00010000 len = 0x00002FA8 CREGISTER=28 /* 12kB Shared RAM */
        GLB_BUF         : org = 0x00012FA8 len = 0x00000058 /* Shared buf in Shared RAM */
\end{verbatim}

This must also appear in ``SECTIONS'':

\begin{verbatim}
SECTIONS {
        (...other memory allocations)
        .share_buff > GLB_BUF, PAGE 2
}
\end{verbatim}

The implementation of the PID controller is done using the usual infinite while loop.

A function ``init\_pid'' sets the shared\_mem struct to some initial values.  Another while loop looks for the init\_flag variable to go high, which is a signal from PRU1 that the system is initialized and ready to start.

The main PID control loop is based on the function ``update\_pid''.  The function reads current values from the shared\_mem struct, and calculates an error value.  Using the PID controller design pattern, errors for proportional, integral, and derivatives terms are defined in terms of C assignment statements.  The terms are summed to create a total error variable ``output\_f''.

The code uses a ``trick'' to emulate floating point mathematics using only fixed integers:

\begin{verbatim}
output = output_f >> SHIFT;
\end{verbatim}

where the ``SHIFT'' was defined as:

\begin{verbatim}
#define SHIFT    0x0E
\end{verbatim}

The above trick is also applied in the integral statement.

A couple of if statements bound the output within limits set in the shared\_mem struct.
And finally the loop control statement implements the negative feedback control:

\begin{verbatim}
pid->output = pid->max_output - output;
\end{verbatim}

\section{The Firmware in PRU1: PID Control (PRU\_IO\_1.c)}

The firmware in PRU1 is less concerned about math, and more concerned with communicating with the world outside the PRU-ICSS.  The C code sets up the RemoteProc messaging framework to allow communications with Linux user-space.  PRU1 is also responsible for writing to the PWM and reading data from the Quadrature Decoder.

The same shared\_mem struct as seen in PRU0 code is defined.  PRU1 needs to both read and write from this data structure.  PRU0 processes the data and returns an output value to write to the PWM which is determined by the PID calculations.

After initialization, the code enters an infinite while loop.  The while loop services three tasks:

\begin{enumerate}
\item
A RemoteProc Messaging interrupt bit is polled, and if it has been set this means that a message has been sent from Linux user-space.  The message is received, and then an ``interrupt service routine'' function is executed.  The ISR consists mainly of a case statement with several character strings used as codes to either set or read variables in the shared\_mem struct.  This is the mechanism whereby the user-space program can control the motor RPM (setpoint) and parameters of the PID control loop.

\item Write the current output value to the PWM:

\begin{verbatim}
CT_ECAP.CAP2_bit.CAP2 = share_buff.pid.output;
\end{verbatim}

This statement is totally cryptic, but it does indeed write a variable to the PWM function of PRU1 and sets the waveform duty-cycle which in applied to the input of the DRV8833 motor control IC.
\item
Read the Quadrature Decoder output.  This is done using the utility function ``get\_enc\_rpm''.  Since this is the controlled parameter of the feedback control loop, the value is written to the shared\_mem struct for processing by the PID calculations in PRU0.
\end{enumerate}

The above is only a high-level description, as the code's features are too numerous to describe every function.  The curious reader is invited to examine the code which is published to the Git repository for further details.



